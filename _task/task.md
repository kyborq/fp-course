## Задание 1

### Функция `isDivisibleBy3or5`

Эта функция принимает один аргумент x (целое число) и проверяет, делится ли это число без остатка на 3 или на 5. Для этого используется операция остатка от деления (mod). В Haskell оператор mod применяется к паре чисел таким образом: x mod y возвращает остаток от деления x на y. Если остаток равен 0, это означает, что x делится на y нацело.

```haskell
isDivisibleBy3or5 x = x `mod` 3 == 0 || x `mod` 5 == 0
```

- x mod 3 == 0 проверяет, делится ли x на 3 без остатка.
- x mod 5 == 0 проверяет, делится ли x на 5 без остатка.
- Оператор || (логическое "ИЛИ") используется для объединения двух условий: функция возвращает True, если хотя бы одно из условий истинно, т.е. если x делится на 3 или на 5.

### Функция `sumDivisibleBy3or5`

Эта функция находит сумму всех чисел, удовлетворяющих критерию isDivisibleBy3or5, в диапазоне от 1 до заданного числа x (не включая само число x, если оно делится на 3 или 5).

```haskell
sumDivisibleBy3or5 x = sum (filter isDivisibleBy3or5 [1 .. x])
```

- [1 .. x] генерирует список всех натуральных чисел от 1 до x.
- filter isDivisibleBy3or5 применяет функцию isDivisibleBy3or5 к каждому элементу этого списка, оставляя только те числа, которые делятся на 3 или на 5. Таким образом, filter возвращает новый список, содержащий только те числа из исходного диапазона, которые удовлетворяют условию.
- sum вычисляет сумму элементов получившегося списка, то есть сумму всех чисел меньше x, делящихся на 3 или на 5.

## Задание 2

### Функция `findPythagoreanTriplet`

Эта функция принимает сумму \(s\) трёх чисел Пифагоровой тройки и возвращает первую (и в данной задаче единственную) найденную тройку, удовлетворяющую условиям.

```haskell
findPythagoreanTriplet s =
  head
    [ (a, b, c)
      | a <- [1 .. s],
        b <- [a + 1 .. s],
        let c = s - a - b,
        a ^ 2 + b ^ 2 == c ^ 2
    ]
```

- Генератор списка `[ (a, b, c) | ... ]` используется для создания списка троек `(a, b, c)`.
- `a <- [1 .. s]` перебирает все возможные значения для `a` от 1 до `s`.
- `b <- [a + 1 .. s]` перебирает значения для `b`, начиная с `a + 1` до `s`. Условие \(a < b < c\) гарантируется тем, что `b` всегда больше `a`, и `c` вычисляется так, что оно больше `b`.
- `let c = s - a - b` определяет значение `c` как разность между заданной суммой \(s\) и суммой \(a + b\). Это гарантирует, что сумма \(a + b + c\) всегда будет равна \(s\).
- `a ^ 2 + b ^ 2 == c ^ 2` является условием, которое должно быть истинным для каждой тройки, то есть сумма квадратов \(a\) и \(b\) должна быть равна квадрату \(c\).
- Функция `head` возвращает первый элемент списка, который удовлетворяет условию, тем самым находя требуемую тройку.

### Функция `productOfTriplet`

Эта функция принимает тройку чисел `(a, b, c)` и возвращает их произведение.

```haskell
productOfTriplet (a, b, c) = a * b * c
```

- `(a, b, c)` — кортеж из трёх чисел.
- `a * b * c` вычисляет произведение этих чисел.

## Задание 3

### Функция `transpose`

Функция `transpose` принимает на вход список списков (матрицу) и возвращает транспонированную матрицу. Рассмотрим подробнее, как она работает:

```haskell
transpose :: [[a]] -> [[a]]
transpose ([] : _) = []
transpose rows = map head rows : transpose (map tail rows)
```

- `transpose ([] : _) = []` обрабатывает случай, когда первый элемент входного списка списков является пустым списком. Это условие указывает на то, что мы достигли конца матрицы при транспонировании, и в результате должны вернуть пустой список, поскольку больше не осталось строк для транспонирования.

- Во второй строке `transpose rows = map head rows : transpose (map tail rows)` происходит основная работа функции:
  - `map head rows` применяет функцию `head` к каждому подсписку (строке матрицы) в `rows`, извлекая первый элемент каждого подсписка. Таким образом, формируется новый список, состоящий из первых элементов всех строк, что соответствует первому столбцу исходной матрицы.
  - `map tail rows` применяет функцию `tail` к каждому подсписку в `rows`, удаляя первый элемент каждого подсписка. Это действие "обрезает" первый столбец из каждой строки, оставляя матрицу без уже обработанных элементов.
  - Рекурсивный вызов `transpose (map tail rows)` применяет функцию транспонирования к оставшейся матрице, позволяя постепенно собирать все столбцы исходной матрицы в строки результирующей матрицы.

## Задание 4

### Функция `isBracketBalanced`

`isBracketBalanced` является основной функцией, которая принимает строку `s` и возвращает `True`, если все скобки в строке корректно сбалансированы, и `False` в противном случае. Она использует вспомогательную функцию `isBalanced` для рекурсивной проверки баланса скобок с использованием стека для отслеживания открытых скобок.

```haskell
isBracketBalanced :: String -> Bool
isBracketBalanced s = isBalanced s []
```

### Вспомогательная функция `isBalanced`

`isBalanced` принимает два аргумента: строку `s` и стек `stack`, представленный списком символов, который изначально пуст. Функция рекурсивно обрабатывает каждый символ строки:

- Если строка пуста и стек также пуст, это означает, что все скобки были правильно сбалансированы, и функция возвращает `True`.
- Если строка пуста, но в стеке остались некоторые элементы, это означает, что есть незакрытые скобки, и функция возвращает `False`.
- В других случаях функция анализирует текущий символ строки:
  - Если символ является открывающей скобкой, он добавляется в стек.
  - Если символ является закрывающей скобкой, функция проверяет, соответствует ли он последней открывающей скобке в стеке (с помощью `bracketsMatch`). Если скобки соответствуют друг другу, последняя открывающая скобка удаляется из стека. Если стек пуст или скобки не соответствуют друг другу, это означает, что скобки не сбалансированы, и функция возвращает `False`.
  - Если текущий символ не является скобкой, функция просто переходит к следующему символу, не изменяя стек.

### Функции для работы со скобками

- `isOpeningBracket` и `isClosingBracket` определяют, является ли символ открывающей или закрывающей скобкой, соответственно.
- `bracketsMatch` проверяет, соответствуют ли друг другу открывающая и закрывающая скобки.
